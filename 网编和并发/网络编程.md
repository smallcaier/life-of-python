

# 网络编程

## 1 socket

## 2 osi 七层协议

​	应  表  会   传  网  数   物

## 3 传送层

###   TCP和UDP

#####   两者的区别

​	tcp  面向连接的,消息可靠,效率相对低,面向流的消息格式
​	udp  面向无连接的,消息不可靠,效率高,面向包的消息格式

### 4 socket处于传输层和应用层之间的一个抽象层

#### tcp socket 

```python
tcp协议的一些特点:长连接,黏包
服务端
import socket
sk = socket.socket()
ip_port = ('127.0.0.1',8001)
sk.bind(ip_port)  #绑定IP地址和端口
sk.listen(5)
conn,addr = sk.accept()  #阻塞
conn.send(b'hello')
msg = conn.recv(1024)    #阻塞,接收和发送的信息都是bytes类型的
print(msg.decode('utf-8'))
conn.close()
sk.close()

客户端
import socket
client = socket.socket()
server_ip_port = ('127.0.0.1',8001)
client.connect(server_ip_port)
from_server_msg = client.recv(1024)
print(from_server_msg.decode('utf-8'))
client.send(b'gunduzi')
client.close()

```

### udp socket

```python
udp协议下的socket
服务端
import socket
sk = socket.socket(type=socket.SOCK_DGRAM)  #udp协议的socket
ip_port = ('127.0.0.1',8001)
sk.bind(ip_port)  #绑定IP地址和端口
msg,client_addr = sk.recvfrom(1024)
print('from_client_msg',msg.decode('utf-8'))
print('client_addr',client_addr)
sk.sendto('你好'.encode('utf-8'),client_addr)
sk.close()

客户端
import socket
client = socket.socket(type=socket.SOCK_DGRAM)
server_ip_port = ('127.0.0.1',8001)
client.sendto('你也好'.encode('utf-8'),server_ip_port)
from_server_msg,server_addr = client.recvfrom(1024)
print(from_server_msg.decode('utf-8'))
client.close()

```



#### tcp

​	三次握手

```
TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了LISTEN（监听）状态；
TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这是报文首部中的同部位SYN=1，同时选择一个初始序列号 seq=x ，此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。
TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号是ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时，TCP服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号。
TCP客户进程收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，自己的序列号seq=x+1，此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。
当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。 

```

​    别忘了看图,参考博客:<https://www.cnblogs.com/clschao/articles/9578922.html#_label9>

​	四次挥手

```
数据传输完毕后，双方都可释放连接。最开始的时候，客户端和服务器都是处于ESTABLISHED状态，然后客户端主动关闭，服务器被动关闭。服务端也可以主动关闭，一个流程。

客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。
服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。
客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。
服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。
客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。
服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。
```



#### socket缓冲区

```
每个socket对象,在创建之后,都会在内存中获取到一块内存空间,作为数据缓冲用的,类似于生产者消费者模型,目的就是做解耦,缓冲.消息发送到输出缓冲区就算是成功了,网络传输是有缓冲区来做的.消息先到对方的输入缓冲区,对方recv是从输入缓冲区获取数据,recv(1024),缓冲区大小一般64k.
输入缓冲区
输出缓冲区  
```



#### tcp的黏包现象

两种现象

```python
1.连续发送的小包,被合并成大包进行发送,Nagle优化算法,造成黏包,并且因为tcp协议的消息是没有消息保护边界的.
2.一次发送的信息超过了对方一次接收数据的最大长度,会剩余一部分在缓冲区里面,下次再发送过来的数据,下次接收,会将第一次没有接收完的和第二次发送多来的一部分,可能一起接收到了.导致数据混乱

解决它的途径:
先发送信息长度,在发送真实数据
struct打包模块
发送方:
ret = struct.pack('i',消息长度(100))  ret:4个长度的bytes类型的数据
send(ret)
send(真实数据)

接收方:
len_msg = recv(4)
len = struct.unpack('i',len_msg)[0]  将4个字节的数据,转换成一个真实数据长度的数值  ,100
recv(len)  接收真实数据

```



#### subprocess模块

执行系统指令并获取系统指令执行结果的一个模块

```python
import subprocess
conn = subprocess.Popen(
	cmd,#dir\ipconfig
	shell=True,
	stdout=subprocess.PIPE,  #标准正确输出
	stderr=subprocess.PIPE   #标准错误输出
)

#获取结果
conn.stdout.read()---bytes类型数据  
conn.stdout.read().decode('utf-8')
conn.stderr.read().decode('utf-8')

paramiko模块,回去学习,ssh,    
```



#### socketserver模块

```
import socketserver
# 大致内部机制
# def f1(conn):
#     conn.send()
# 
# while 1:
#     conn,addr = sk.accept()
#     t = Thread(target=f1,args=(conn))
#     t.start()

class MyServer(socketserver.BaseRequestHandler):
    def handle(self):
        self.request.recv(1024)   #conn
        self.request.send(b'xxx')
    
if __name__ == '__main__':
    ip_port = ('127.0.0.1',8001)
    server = socketserver.ThreadingTCPServer(ip_port,MyServer)
    server.serve_forever()
```



补充

```
CS架构

client  server  

​	BS架构

​	browser  server

mac地址   全球唯一标示,  ipconfig,ifconfig

ip地址       4个点分十进制

交换机      升级版的集线器,集线器将所有连接集线器的电脑互相联通起来

网卡     接收电信号

路由器    管理内网,连接外网,网关,对外的ip地址

局域网\内网   allow_host = ['*']  ---  0.0.0.0

路由协议  选择最优路径

arp协议   通过ip地址获取mac地址

广播    子网   同一个ip地址段.      

广播风暴     造成网络拥堵,数据不安全

DNS   域名解析   通过域名找到ip地址
```













































